package amyc
package codegen

import analyzer._
import amyc.ast.Identifier
import amyc.ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import amyc.utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        val comment = Comment(fd.toString)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          comment <:> body
        }
      }
    }


    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        case IntLiteral(i) =>
          // Push i to the stack.
          // The comments are optional but can help you debug.
          Comment(expr.toString) <:> Const(i)
        
        case BooleanLiteral(b) =>
          // 1 represents true, 0 false
          Comment(expr.toString) <:> Const(if b then 1 else 0)

        case StringLiteral(s) =>
          // String to Code is given to us by mkString
          Comment(expr.toString) <:> mkString(s)
        
        case UnitLiteral() =>
          // Unit returns 0 by convention
          Comment(expr.toString) <:> Const(0)
        
        case Variable(name) =>
          Comment(expr.toString) <:> GetLocal(locals(name))

        // Binary operators
        // Push the left and right expr, then appy operation (takes the top 2 values of the stack, does
        // the operation on them, and pushes the result back on the stack)
        case Plus(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case LessThan(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
        case AmyAnd(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> 
          cgExpr(lhs) <:>
          If_i32 <:> cgExpr(rhs) <:> 
          Else <:> Const(0) <:> 
          End
        case AmyOr(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> 
          cgExpr(lhs) <:>
          If_i32 <:> Const(1) <:> 
          Else <:> cgExpr(rhs) <:> 
          End
        case Equals(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case Concat(lhs: Expr, rhs: Expr) =>
          Comment(expr.toString) <:> cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)

        // Unary operators
        case Not(e: Expr) =>
          Comment(expr.toString) <:> cgExpr(e) <:> Eqz

        case Neg(e: Expr) =>
          Comment(expr.toString) <:> Const(0) <:> cgExpr(e) <:> Sub

        // Function/constructor call
        case AmyCall(qname: QualifiedName, args: List[Expr]) =>
          val cgArgs = args.map(arg => cgExpr(arg))
          table.getConstructor(qname) match {
          // Constructor structure example
          /* Cons(42, Nil())

          | address |  value  |
          |---------|---------|
          |    0    |    1    | \ 
          |    1    |         | | constructor id.
          |    2    |         | | Cons
          |    3    |         | /
          |    4    |   42    | \
          |    5    |         | | first member: int
          |    6    |         | |  42
          |    7    |         | /
          |    8    |  1234   | \
          |    9    |         | | seconder member: pointer to Nil
          |   10    |         | | 1234
          |   11    |         | /

          Field offset = 4 + 4 * field number

          */

            case Some(constructor) => 
              def argsToCode(cgArgs: List[Code], localAddress: Int): List[Code] = {
                cgArgs.zipWithIndex.map(
                  (arg, i) => GetLocal(localAddress) <:> Const(4 + 4 * i) <:> Add <:> arg <:> Store
                )
              }

              val address = lh.getFreshLocal();
              val argsCode = argsToCode(cgArgs, address);

              GetGlobal(Utils.memoryBoundary) <:> 
              SetLocal(address) <:>
              GetGlobal(Utils.memoryBoundary) <:> 
              Const(4 + 4 * argsCode.size) <:> 
              Add <:>
              SetGlobal(Utils.memoryBoundary) <:> 
              GetLocal(address) <:> 
              Const(constructor.index) <:> 
              Store <:> 
              argsCode <:> GetLocal(address)

            // Function Call
            case None =>
              cgArgs <:> Call(Utils.fullName(table.getFunction(qname).get.owner, qname))
          }

        // The ; operator
        case Sequence(e1: Expr, e2: Expr) => 
          Comment(expr.toString) <:> cgExpr(e1) <:> Drop <:> cgExpr(e2)

        // Local variable definition
        case Let(df: ParamDef, value: Expr, body: Expr) => 
          val address = lh.getFreshLocal()
          Comment(expr.toString) <:>         
          cgExpr(value) <:> SetLocal(address) <:> 
          cgExpr(body)(locals + (df.name -> address), lh)

        // If-then-else
        case Ite(cond: Expr, thenn: Expr, elze: Expr) => 
          Comment(expr.toString) <:> 
          cgExpr(cond) <:> 
          If_i32 <:> cgExpr(thenn) <:> 
          Else <:> cgExpr(elze) <:> 
          End

        // Pattern matching    
        case Match(scrut, cases) => 
          // Checks if a value matches a pattern.
          // Assumes value is on top of stack (and CONSUMES it)
          // Returns the code to check the value, and a map of bindings.
          def matchAndBind(value: Code, pat: Pattern): (Code, Map[Identifier, Int]) = {
            pat match 
              case IdPattern(id) =>
                val localAddress = lh.getFreshLocal()
                (Comment(pat.toString) <:> 
                value <:>
                // Assign val to id.
                SetLocal(localAddress) <:> 
                // Return true (IdPattern always matches).
                Const(1),
                // Let the code generation of the expression which corresponds to this pattern
                // know that the bound id is at local idLocal.
                locals + (id -> localAddress))
            
              case WildcardPattern() => 
                (Comment(pat.toString) <:> 
                Const(1), 
                locals)

              case LiteralPattern(lit) => 
                (Comment(pat.toString) <:>
                value <:>
                cgExpr(lit) <:> 
                Eq, 
                locals)
                           
              //case LiteralPattern(lit) => (value <:> cgExpr(lit) <:> Eq, locals)

              case CaseClassPattern(constr: QualifiedName, args: List[Pattern]) =>
                val localAddress = lh.getFreshLocal()
                val idx = table.getConstructor(constr).get.index

                val bindedCode = 
                  args
                  .zipWithIndex
                  .map{
                    case (pattern, index) => 
                      matchAndBind(GetLocal(localAddress) <:> Utils.adtField(index) <:> Load, pattern)
                  }

                val code = bindedCode.map(_._1)

                val argsCode: Code = {
                  if args.isEmpty then Const(1)
                  else if args.length == 1 then code
                  else code <:> args.tail.map(arg => And)
                }

                val caseClassCode =
                  value <:> SetLocal(localAddress) <:> GetLocal(localAddress) <:> Load <:>
                  Const(idx) <:> Eq <:> 
                  If_i32 <:> argsCode <:> 
                  Else <:> Const(0) <:> 
                  End

                val newLocals = 
                  locals ++
                  bindedCode
                  .map(_._2)
                  .foldLeft(Map[Identifier, Int]())((acc, elem) => acc ++ elem)

                (caseClassCode, newLocals)
            
          }

          val scrutLocal = lh.getFreshLocal()
          val caseCodes = 
            cases.map(
              caze => (caze, matchAndBind(GetLocal(scrutLocal), caze.pat))).map{
                case (caze,(code, bind)) => code <:> If_i32 <:> cgExpr(caze.expr)(bind, lh) <:> Else
            }

          cgExpr(scrut) <:> SetLocal(scrutLocal) <:> caseCodes <:> 
          mkString("Matching error") <:> Call("Std_printString") <:> 
          Unreachable <:> cases.map(caze => End)

        case Error(msg) =>
          cgExpr(StringLiteral("Error : ")) <:> 
          cgExpr(msg) <:> Call("Std_printString") <:> Unreachable
        case _ => 
          cgExpr(StringLiteral("Unkown expression encountered when generating code")) <:>
          Unreachable
      
      }

    }

  
    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
