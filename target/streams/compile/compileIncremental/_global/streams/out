[0m[[0m[0mdebug[0m] [0m[0m[zinc] IncrementalCompile -----------[0m
[0m[[0m[0mdebug[0m] [0m[0mIncrementalCompile.incrementalCompile[0m
[0m[[0m[0mdebug[0m] [0m[0mprevious = Stamps for: 196 products, 15 sources, 4 libraries[0m
[0m[[0m[0mdebug[0m] [0m[0mcurrent source = Set(${BASE}/src/main/scala/amyc/ast/TreeModule.scala, ${BASE}/src/main/scala/amyc/utils/Pipeline.scala, ${BASE}/src/main/scala/amyc/utils/Context.scala, ${BASE}/src/main/scala/amyc/parsing/Parser.scala, ${BASE}/src/main/scala/amyc/parsing/Tokens.scala, ${BASE}/src/main/scala/amyc/parsing/Lexer.scala, ${BASE}/src/main/scala/amyc/utils/Env.scala, ${BASE}/src/main/scala/amyc/utils/Document.scala, ${BASE}/src/main/scala/amyc/utils/UniqueCounter.scala, ${BASE}/src/main/scala/amyc/utils/Position.scala, ${BASE}/src/main/scala/amyc/lab3.main.scala, ${BASE}/src/main/scala/amyc/utils/Reporter.scala, ${BASE}/src/main/scala/amyc/utils/AmycFatalError.scala, ${BASE}/src/main/scala/amyc/ast/Printer.scala, ${BASE}/src/main/scala/amyc/ast/Identifier.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating '${BASE}/lib/amyc-frontend-1.7.0.jar' because could not find class amyc.analyzer.SymbolTable on the classpath.[0m
[0m[[0m[0mdebug[0m] [0m[0m> initialChanges = InitialChanges(Changes(added = Set(${BASE}/src/main/scala/amyc/lab3.main.scala, ${BASE}/src/main/scala/amyc/parsing/Parser.scala), removed = Set(${BASE}/src/main/scala/amyc/lab2.main.scala, ${BASE}/src/main/scala/amyc/interpreter/Interpreter.scala), changed = Set(${BASE}/src/main/scala/amyc/parsing/Lexer.scala), unmodified = ...),Set(),Set(${BASE}/lib/amyc-frontend-1.7.0.jar),API Changes: Set())[0m
[0m[[0m[0mdebug[0m] [0m[0m[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial source changes:[0m
[0m[[0m[0mdebug[0m] [0m[0m	removed: Set(${BASE}/src/main/scala/amyc/lab2.main.scala, ${BASE}/src/main/scala/amyc/interpreter/Interpreter.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	added: Set(${BASE}/src/main/scala/amyc/lab3.main.scala, ${BASE}/src/main/scala/amyc/parsing/Parser.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	modified: Set(${BASE}/src/main/scala/amyc/parsing/Lexer.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated products: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mExternal API changes: API Changes: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mModified binary dependencies: Set(${BASE}/lib/amyc-frontend-1.7.0.jar)[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial directly invalidated classes: Set(amyc.Lab2, amyc.interpreter.Interpreter$.Value, amyc.interpreter.Interpreter$.StringValue, amyc.interpreter.Interpreter$.CaseClassValue, amyc.parsing.DisplayTokens, amyc.interpreter.Interpreter, amyc.interpreter.Interpreter$.BooleanValue, amyc.interpreter.Interpreter$.UnitValue, amyc.parsing.Lexer, amyc.interpreter.Interpreter$.IntValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mSources indirectly invalidated by:[0m
[0m[[0m[0mdebug[0m] [0m[0m	product: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0m	binary dep: Set(${BASE}/src/main/scala/amyc/interpreter/Interpreter.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0m	external source: Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated classes: Set(amyc.Lab2, amyc.interpreter.Interpreter$.Value, amyc.interpreter.Interpreter$.StringValue, amyc.interpreter.Interpreter$.CaseClassValue, amyc.parsing.DisplayTokens, amyc.interpreter.Interpreter, amyc.interpreter.Interpreter$.BooleanValue, amyc.interpreter.Interpreter$.UnitValue, amyc.parsing.Lexer, amyc.interpreter.Interpreter$.IntValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mAll initially invalidated sources:Set(${BASE}/src/main/scala/amyc/lab3.main.scala, ${BASE}/src/main/scala/amyc/parsing/Parser.scala, ${BASE}/src/main/scala/amyc/parsing/Lexer.scala, ${BASE}/src/main/scala/amyc/interpreter/Interpreter.scala)[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.Lab2, amyc.interpreter.Interpreter$.Value, amyc.interpreter.Interpreter$.StringValue, amyc.interpreter.Interpreter$.CaseClassValue, amyc.parsing.DisplayTokens, amyc.interpreter.Interpreter, amyc.interpreter.Interpreter$.BooleanValue, amyc.interpreter.Interpreter$.UnitValue, amyc.parsing.Lexer, amyc.interpreter.Interpreter$.IntValue[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.interpreter.Interpreter$.StringValue by amyc.interpreter.Interpreter$.Value[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.interpreter.Interpreter$.CaseClassValue by amyc.interpreter.Interpreter$.Value[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.interpreter.Interpreter$.BooleanValue by amyc.interpreter.Interpreter$.Value[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.interpreter.Interpreter$.UnitValue by amyc.interpreter.Interpreter$.Value[0m
[0m[[0m[0mdebug[0m] [0m[0mIncluding amyc.interpreter.Interpreter$.IntValue by amyc.interpreter.Interpreter$.Value[0m
[0m[[0m[0mdebug[0m] [0m[0mcompilation cycle 1[0m
[0m[[0m[0minfo[0m] [0m[0mcompiling 3 Scala sources to /Users/anjim1/Desktop/CS320/cs320-group16/target/scala-3.1.3/classes ...[0m
[0m[[0m[0mdebug[0m] [0m[0mReturning already retrieved and compiled bridge: /Users/anjim1/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-sbt-bridge/3.1.3/scala3-sbt-bridge-3.1.3.jar.[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] Running cached compiler 10ac9376 for Scala Compiler version 3.1.3[0m
[0m[[0m[0mdebug[0m] [0m[0m[zinc] The Scala compiler is invoked with:[0m
[0m[[0m[0mdebug[0m] [0m[0m	-feature[0m
[0m[[0m[0mdebug[0m] [0m[0m	-bootclasspath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/Users/anjim1/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala3-library_3/3.1.3/scala3-library_3-3.1.3.jar:/Users/anjim1/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.8/scala-library-2.13.8.jar[0m
[0m[[0m[0mdebug[0m] [0m[0m	-classpath[0m
[0m[[0m[0mdebug[0m] [0m[0m	/Users/anjim1/Desktop/CS320/cs320-group16/target/scala-3.1.3/classes:/Users/anjim1/Desktop/CS320/cs320-group16/lib/silex_3-0.6.jar:/Users/anjim1/Desktop/CS320/cs320-group16/lib/scallion_3-0.6.jar[0m
[0m[[0m[0mdebug[0m] [0m[0mScala compilation took 6.161714594 s[0m
[0m[[0m[0mdebug[0m] [0m[0mdone compiling[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter$.IntValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.interpreter.Interpreter$.IntValue[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter$.IntValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter$.IntValue,ModifiedNames(changes = UsedName(MirroredElemLabels,[Default]), UsedName(i,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(IntValue,[Default]), UsedName(clone,[Default]), UsedName(_1,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName(copy$default$1,[Default]), UsedName(IntValue;init;$,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(MirroredLabel,[Default]), UsedName(asString,[Default]), UsedName(unapply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(IntValue;init;,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(copy,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(apply,[Default]), UsedName(asInt,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter$.IntValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(MirroredElemLabels,[Default]), UsedName(i,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(IntValue,[Default]), UsedName(clone,[Default]), UsedName(_1,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName(copy$default$1,[Default]), UsedName(IntValue;init;$,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(MirroredLabel,[Default]), UsedName(asString,[Default]), UsedName(unapply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(IntValue;init;,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(copy,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(apply,[Default]), UsedName(asInt,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.interpreter.Interpreter$.IntValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter$.CaseClassValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.interpreter.Interpreter$.CaseClassValue[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter$.CaseClassValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter$.CaseClassValue,ModifiedNames(changes = UsedName(MirroredElemLabels,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(_1,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName(copy$default$1,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(CaseClassValue;init;,[Default]), UsedName(_2,[Default]), UsedName(MirroredLabel,[Default]), UsedName(asString,[Default]), UsedName(unapply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(constructor,[Default]), UsedName(synchronized,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(CaseClassValue;init;$,[Default]), UsedName(copy$default$2,[Default]), UsedName(args,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(copy,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(CaseClassValue,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(apply,[Default]), UsedName(asInt,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter$.CaseClassValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(MirroredElemLabels,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(_1,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName(copy$default$1,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(CaseClassValue;init;,[Default]), UsedName(_2,[Default]), UsedName(MirroredLabel,[Default]), UsedName(asString,[Default]), UsedName(unapply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(constructor,[Default]), UsedName(synchronized,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(CaseClassValue;init;$,[Default]), UsedName(copy$default$2,[Default]), UsedName(args,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(copy,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(CaseClassValue,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(apply,[Default]), UsedName(asInt,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.interpreter.Interpreter$.CaseClassValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.parsing.Parser...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.parsing.Parser[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.parsing.Parser)[0m
[0m[[0m[0mdebug[0m] [0m[0mThe following member ref dependencies of amyc.parsing.Parser are invalidated:[0m
[0m[[0m[0mdebug[0m] [0m[0m	amyc.Lab3[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.parsing.Parser,ModifiedNames(changes = UsedName(Parsing;init;,[Default]), UsedName(repsep$default$3,[Default]), UsedName(Associativity,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(infixRight,[Default]), UsedName(UnsafeImplicits,[Default]), UsedName(Uninteresting,[Default]), UsedName(isInstanceOf,[Default]), UsedName(simpleExpr,[Default]), UsedName(identifierType,[Default]), UsedName(prefixes,[Default]), UsedName(delimiter,[Implicit]), UsedName(Enumeration;init;,[Default]), UsedName(rep1sep,[Default]), UsedName(pattern,[Default]), UsedName(RightAssociative,[Default]), UsedName(LevelDecorator,[Default, Implicit]), UsedName(postfixes$default$4,[Default]), UsedName(operators,[Default]), UsedName(run,[Default]), UsedName(clone,[Default]), UsedName(andThen,[Default]), UsedName(many$default$2,[Default]), UsedName(notifyAll,[Default]), UsedName(definition,[Default]), UsedName(getKind,[Default]), UsedName(Properties,[Default]), UsedName(failure,[Default]), UsedName(epsilon,[Default]), UsedName(repsep,[Default]), UsedName(literalPattern,[Default]), UsedName(RecId,[Default]), UsedName(accept,[Default]), UsedName(getClass,[Default]), UsedName(many1,[Default]), UsedName(eq,[Default]), UsedName(debug$default$3,[Default]), UsedName($asInstanceOf,[Default]), UsedName(many1$default$2,[Default]), UsedName(!=,[Default]), UsedName(rep1sep$default$3,[Default]), UsedName(op,[Default]), UsedName(parameter,[Default]), UsedName(module,[Default]), UsedName(hashCode,[Default]), UsedName(Level,[Default]), UsedName(Syntax,[Default]), UsedName(program,[Default]), UsedName(Parsed,[Default]), UsedName(operators$default$4,[Default]), UsedName(Syntaxes;init;,[Default]), UsedName(debug$default$2,[Default]), UsedName(Enumerator,[Default]), UsedName(Parser,[Default]), UsedName(literal,[Default]), UsedName(debugString,[Default]), UsedName(Pipeline;init;,[Default]), UsedName(SafeImplicits,[Default]), UsedName(ParseResult,[Default]), UsedName($isInstanceOf,[Default]), UsedName(prefixes$default$4,[Default]), UsedName(Implicits,[Default]), UsedName(Conflict,[Default]), UsedName(primitiveType,[Default]), UsedName(UnexpectedToken,[Default]), UsedName(synchronized,[Default]), UsedName(identifier,[Default]), UsedName(==,[Default]), UsedName(debugString$default$3,[Default]), UsedName(asInstanceOf,[Default]), UsedName(PrettyPrinting;init;,[Default]), UsedName(Debug;init;,[Default]), UsedName(elem,[Default]), UsedName(debug,[Default]), UsedName(wildPattern,[Default]), UsedName(recursive,[Default]), UsedName(infixLeft,[Default]), UsedName(Token,[Default]), UsedName(infixRight$default$4,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(ConflictException,[Default]), UsedName(infixLeft$default$4,[Default]), UsedName(parameters,[Default]), UsedName(Parser;init;$,[Default]), UsedName(checkLL1,[Default]), UsedName(Parsers;init;,[Default]), UsedName(ne,[Default]), UsedName(PrettyPrinter,[Default]), UsedName(syntaxToLL1Properties,[Implicit]), UsedName(many,[Default]), UsedName(##,[Default]), UsedName(opt,[Default]), UsedName(Operators;init;,[Default]), UsedName(Object;init;,[Default]), UsedName(typeTree,[Default]), UsedName(LeftAssociative,[Default]), UsedName(Kind,[Default]), UsedName(eof,[Default]), UsedName(Mark,[Default]), UsedName(expr,[Default]), UsedName(postfixes,[Default]), UsedName(variableOrCall,[Default]), UsedName(oneOf,[Default]), UsedName(Skip,[Default]), UsedName(UnexpectedEnd,[Default]), UsedName(accept$default$3,[Default]), UsedName(equals,[Default]), UsedName(debugString$default$2,[Default]), UsedName(identifierPos,[Default]), UsedName(kw,[Default]))) invalidates 2 classes due to The amyc.parsing.Parser has the following implicit definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(delimiter,[Implicit]), UsedName(LevelDecorator,[Default, Implicit]), UsedName(syntaxToLL1Properties,[Implicit]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.parsing.Parser)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > by member reference: Set(amyc.Lab3)[0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.Lab2...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.Lab2[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.Lab2)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.Lab2,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]), UsedName(Lab2;init;$,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(main,[Default]), UsedName(Lab2,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The amyc.Lab2 has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]), UsedName(Lab2;init;$,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(main,[Default]), UsedName(Lab2,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.Lab2)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.Lab3...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.Lab3[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.Lab3)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.Lab3,ModifiedNames(changes = UsedName(Lab3;init;$,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(treePrinterN,[Default]), UsedName(clone,[Default]), UsedName(Lab3,[Default]), UsedName(notifyAll,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(main,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The amyc.Lab3 has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Lab3;init;$,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(treePrinterN,[Default]), UsedName(clone,[Default]), UsedName(Lab3,[Default]), UsedName(notifyAll,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(main,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.Lab3)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter$.Value...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.interpreter.Interpreter$.Value[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter$.Value)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter$.Value,ModifiedNames(changes = UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]), UsedName(Value,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(asString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(asInt,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter$.Value has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]), UsedName(Value,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(asString,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(asInt,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.interpreter.Interpreter$.Value)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.interpreter.Interpreter[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter,ModifiedNames(changes = UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(IntValue,[Default]), UsedName(Interpreter;init;$,[Default]), UsedName(run,[Default]), UsedName(clone,[Default]), UsedName(andThen,[Default]), UsedName(notifyAll,[Default]), UsedName(Value,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(BooleanValue,[Default]), UsedName(Pipeline;init;,[Default]), UsedName(UnitValue,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Interpreter,[Default]), UsedName(synchronized,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(StringValue,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(CaseClassValue,[Default]), UsedName(equals,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(isInstanceOf,[Default]), UsedName(IntValue,[Default]), UsedName(Interpreter;init;$,[Default]), UsedName(run,[Default]), UsedName(clone,[Default]), UsedName(andThen,[Default]), UsedName(notifyAll,[Default]), UsedName(Value,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(BooleanValue,[Default]), UsedName(Pipeline;init;,[Default]), UsedName(UnitValue,[Default]), UsedName($isInstanceOf,[Default]), UsedName(Interpreter,[Default]), UsedName(synchronized,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(StringValue,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(CaseClassValue,[Default]), UsedName(equals,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.interpreter.Interpreter)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter$.UnitValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.interpreter.Interpreter$.UnitValue[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter$.UnitValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter$.UnitValue,ModifiedNames(changes = UsedName(MirroredElemLabels,[Default]), UsedName(MirroredType,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Singleton;init;,[Default]), UsedName(MirroredElemTypes,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(MirroredLabel,[Default]), UsedName(asString,[Default]), UsedName(UnitValue,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(asInt,[Default]), UsedName(UnitValue;init;$,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter$.UnitValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(MirroredElemLabels,[Default]), UsedName(MirroredType,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(Singleton;init;,[Default]), UsedName(MirroredElemTypes,[Default]), UsedName(clone,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(MirroredLabel,[Default]), UsedName(asString,[Default]), UsedName(UnitValue,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(asInt,[Default]), UsedName(UnitValue;init;$,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.interpreter.Interpreter$.UnitValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter$.StringValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.interpreter.Interpreter$.StringValue[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter$.StringValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter$.StringValue,ModifiedNames(changes = UsedName(MirroredElemLabels,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(_1,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName(s,[Default]), UsedName(copy$default$1,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(MirroredLabel,[Default]), UsedName(asString,[Default]), UsedName(unapply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(StringValue;init;,[Default]), UsedName(copy,[Default]), UsedName(StringValue,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(StringValue;init;$,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(apply,[Default]), UsedName(asInt,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter$.StringValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(MirroredElemLabels,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(_1,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName(s,[Default]), UsedName(copy$default$1,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(MirroredLabel,[Default]), UsedName(asString,[Default]), UsedName(unapply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(StringValue;init;,[Default]), UsedName(copy,[Default]), UsedName(StringValue,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(StringValue;init;$,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(apply,[Default]), UsedName(asInt,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.interpreter.Interpreter$.StringValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidating (transitively) by inheritance from amyc.interpreter.Interpreter$.BooleanValue...[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: amyc.interpreter.Interpreter$.BooleanValue[0m
[0m[[0m[0mdebug[0m] [0m[0mInvalidated by transitive inheritance dependency: Set(amyc.interpreter.Interpreter$.BooleanValue)[0m
[0m[[0m[0mdebug[0m] [0m[0mChange NamesChange(amyc.interpreter.Interpreter$.BooleanValue,ModifiedNames(changes = UsedName(MirroredElemLabels,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(b,[Default]), UsedName(_1,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName(copy$default$1,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(MirroredLabel,[Default]), UsedName(BooleanValue,[Default]), UsedName(asString,[Default]), UsedName(unapply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(BooleanValue;init;$,[Default]), UsedName(copy,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(BooleanValue;init;,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(apply,[Default]), UsedName(asInt,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]))) invalidates 1 classes due to The amyc.interpreter.Interpreter$.BooleanValue has the following regular definitions changed:[0m
[0m[[0m[0mdebug[0m] [0m[0m	UsedName(MirroredElemLabels,[Default]), UsedName(Value;init;,[Default]), UsedName(toString,[Default]), UsedName(finalize,[Default]), UsedName(canEqual,[Default]), UsedName(isInstanceOf,[Default]), UsedName(clone,[Default]), UsedName(b,[Default]), UsedName(_1,[Default]), UsedName(notifyAll,[Default]), UsedName(MirroredMonoType,[Default]), UsedName(asBoolean,[Default]), UsedName(getClass,[Default]), UsedName(eq,[Default]), UsedName(copy$default$1,[Default]), UsedName($asInstanceOf,[Default]), UsedName(!=,[Default]), UsedName(hashCode,[Default]), UsedName(MirroredLabel,[Default]), UsedName(BooleanValue,[Default]), UsedName(asString,[Default]), UsedName(unapply,[Default]), UsedName($isInstanceOf,[Default]), UsedName(synchronized,[Default]), UsedName(fromProduct,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(productElement,[Default]), UsedName(productArity,[Default]), UsedName(BooleanValue;init;$,[Default]), UsedName(copy,[Default]), UsedName(notify,[Default]), UsedName(wait,[Default]), UsedName(BooleanValue;init;,[Default]), UsedName(productElementName,[Default]), UsedName(ne,[Default]), UsedName(##,[Default]), UsedName(Object;init;,[Default]), UsedName(productPrefix,[Default]), UsedName(Mirror;init;,[Default]), UsedName(apply,[Default]), UsedName(asInt,[Default]), UsedName(Serializable;init;,[Default]), UsedName(equals,[Default]), UsedName(Product;init;,[Default]).[0m
[0m[[0m[0mdebug[0m] [0m[0m  > by transitive inheritance: Set(amyc.interpreter.Interpreter$.BooleanValue)[0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m  > [0m
[0m[[0m[0mdebug[0m] [0m[0m        [0m
[0m[[0m[0mdebug[0m] [0m[0mNew invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0mInitial set of included nodes: [0m
[0m[[0m[0mdebug[0m] [0m[0mPreviously invalidated, but (transitively) depend on new invalidations:[0m
[0m[[0m[0mdebug[0m] [0m[0mFinal step, transitive dependencies:[0m
[0m[[0m[0mdebug[0m] [0m[0m	Set()[0m
[0m[[0m[0mdebug[0m] [0m[0mNo classes were invalidated.[0m
